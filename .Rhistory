uncertainty95_segment <- list()
for(i in 1:n.user){
uncertainty95_segment [i] = quantile(res$mcmc[,i],probs=c(0.025,0.975))
}
nS.user=2
for(i in 1:n.user){
uncertainty95_segment [i] = quantile(res$mcmc[,i],probs=c(0.025,0.975))
}
for(i in 1:nS.user){
uncertainty95_segment [i] = quantile(res$mcmc[,i],probs=c(0.025,0.975))
}
for(i in 1:nS.user){
uncertainty95_segment [[i]] = quantile(res$mcmc[,i],probs=c(0.025,0.975))
}
uncertainty95_segment
# Separate and assign information by identified stable period
res$data.p
# DIC estimation
res$DIC
# Plot
obs_segmented <- data.frame()
for(i in 1:length(res$data.p$obs.p)){
obs_segmented_temp=cbind(obs=res$data.p$obs.p[[i]],period=i)
obs_segmented=rbind(obs_segmented,obs_segmented_temp)
}
obs_segmented
res$data.p$obs.p
plot(x=obs_segmented$obs,
col=factor(obs_segmented$period),
pch=16,
main='Final segmentation',
ylab='obs',
xlab='time')
lines(x=res$data.p$time.p[[1]],y=res$segments[[1]],col='blue')
uncertainty95_segment[[1]]]
uncertainty95_segment[[1]]
uncertainty95_segment
plot(x=obs_segmented$obs,
col=factor(obs_segmented$period),
pch=16,
main='Final segmentation',
ylab='obs',
xlab='time')
for(i in 1:nS.user){
lines(x=res$data.p$time.p[[i]],y=res$segments[[i]],col='blue')
rect(xleft=uncertainty95_segment[[i]][1],
xright=uncertainty95_shift[[i]][2],
ybottom=min(obs)*2,
ytop=max(obs)*2,
col= rgb(0,1,0,alpha=0.2),
border = 'transparent')
}
res$data.p$time.p[[i]]
plot(x=obs_segmented$obs,
col=factor(obs_segmented$period),
pch=16,
main='Final segmentation',
ylab='obs',
xlab='time')
for(i in 1:nS.user){
lines(x=res$data.p$time.p[[i]],y=res$segments[[i]],col='blue')
rect(xleft=res$data.p$time.p[[i]][1],
xright=rev(res$data.p$time.p[[i]])[1],
ybottom=uncertainty95_segment[[i]][1],
ytop=uncertainty95_shift[[i]][2],
col= rgb(0,1,0,alpha=0.2),
border = 'transparent')
}
res$data.p$time.p[[i]][1].
res$data.p$time.p[[i]][1]
i
i <- 1
res$data.p$time.p[[i]][1]
rev(res$data.p$time.p[[i]])[1]
uncertainty95_segment[[i]][1]
uncertainty95_shift[[i]][2]
plot(x=obs_segmented$obs,
col=factor(obs_segmented$period),
pch=16,
main='Final segmentation',
ylab='obs',
xlab='time')
for(i in 1:nS.user){
lines(x=res$data.p$time.p[[i]],y=res$segments[[i]],col='blue')
rect(xleft=res$data.p$time.p[[i]][1],
xright=rev(res$data.p$time.p[[i]])[1],
ybottom=uncertainty95_segment[[i]][1],
ytop=uncertainty95_segment[[i]][2],
col= rgb(0,1,0,alpha=0.2),
border = 'transparent')
}
plot(x=obs_segmented$obs,
col=factor(obs_segmented$period),
pch=16,
main='Final segmentation',
ylab='obs',
xlab='time')
for(i in 1:nS.user){
lines(x=res$data.p$time.p[[i]],y=res$segments[[i]],col='blue')
rect(xleft=res$data.p$time.p[[i]][1],
xright=rev(res$data.p$time.p[[i]])[1],
ybottom=uncertainty95_segment[[i]][1],
ytop=uncertainty95_segment[[i]][2],
col= rgb(0,0,255,alpha=0.2),
border = 'transparent')
}
plot(x=obs_segmented$obs,
col=factor(obs_segmented$period),
pch=16,
main='Final segmentation',
ylab='obs',
xlab='time')
i <- 1
lines(x=res$data.p$time.p[[i]],y=res$segments[[i]],col='blue')
rect(xleft=res$data.p$time.p[[i]][1],
xright=rev(res$data.p$time.p[[i]])[1],
ybottom=uncertainty95_segment[[i]][1],
ytop=uncertainty95_segment[[i]][2],
col= rgb(0,0,255,alpha=0.2),
border = 'transparent')
?rgb
rect(xleft=uncertainty95_shift[1],
xright=uncertainty95_shift[2],
ybottom=min(obs)*2,
ytop=max(obs)*2,
col= rgb(blue,alpha=0.2),
border = 'transparent')
rect(xleft=uncertainty95_shift[1],
xright=uncertainty95_shift[2],
ybottom=min(obs)*2,
ytop=max(obs)*2,
col= rgb('blue',alpha=0.2),
border = 'transparent').
rect(xleft=uncertainty95_shift[1],
xright=uncertainty95_shift[2],
ybottom=min(obs)*2,
ytop=max(obs)*2,
col= rgb('blue',alpha=0.2),
border = 'transparent')
plot(x=obs_segmented$obs,
col=factor(obs_segmented$period),
pch=16,
main='Final segmentation',
ylab='obs',
xlab='time')
for(i in 1:nS.user){
lines(x=res$data.p$time.p[[i]],y=res$segments[[i]],col='blue')
rect(xleft=res$data.p$time.p[[i]][1],
xright=rev(res$data.p$time.p[[i]])[1],
ybottom=uncertainty95_segment[[i]][1],
ytop=uncertainty95_segment[[i]][2],
col= rgb('blue',alpha=0.2),
border = 'transparent')
}
i
plot(x=obs_segmented$obs,
col=factor(obs_segmented$period),
pch=16,
main='Final segmentation',
ylab='obs',
xlab='time')
for(i in 1:nS.user){
lines(x=res$data.p$time.p[[i]],y=res$segments[[i]],col='blue')
rect(xleft=res$data.p$time.p[[i]][1],
xright=rev(res$data.p$time.p[[i]])[1],
ybottom=uncertainty95_segment[[i]][1],
ytop=uncertainty95_segment[[i]][2],
col= rgb(0,0,1,alpha=0.2),
border = 'transparent')
}
res$data.p$time.p
res$tau
uncertainty95_shift
uncertainty95_shift
plot(x=obs_segmented$obs,
col=factor(obs_segmented$period),
pch=16,
main='Final segmentation',
ylab='obs',
xlab='time')
for(i in 1:nS.user){
lines(x=res$data.p$time.p[[i]],y=res$segments[[i]],col='blue')
rect(xleft=res$data.p$time.p[[i]][1],
xright=rev(res$data.p$time.p[[i]])[1],
ybottom=uncertainty95_segment[[i]][1],
ytop=uncertainty95_segment[[i]][2],
col= rgb(0,0,1,alpha=0.2),
border = 'transparent')
}
for(i in 1:(nS.user-1)){
abline(v=res$tau,col='green', lwd=2)
rect(xleft=uncertainty95_shift[[i]][1],
xright=rev(uncertainty95_shift[[i]])[1],
ybottom=min(obs)*2,
ytop=max(obs)*2,
col= rgb(0,1,0,alpha=0.2),
border = 'transparent')
}
plot(x=obs_segmented$obs,
col=factor(obs_segmented$period),
pch=16,
main='Final segmentation',
ylab='obs',
xlab='time')
for(i in 1:nS.user){
lines(x=res$data.p$time.p[[i]],y=res$segments[[i]],col='blue')
rect(xleft=res$data.p$time.p[[i]][1],
xright=rev(res$data.p$time.p[[i]])[1],
ybottom=uncertainty95_segment[[i]][1],
ytop=uncertainty95_segment[[i]][2],
col= rgb(0,0,1,alpha=0.2),
border = 'transparent')
}
i <- 1
abline(v=res$tau,col='green', lwd=2)
uncertainty95_shift
plot(x=obs_segmented$obs,
col=factor(obs_segmented$period),
pch=16,
main='Final segmentation',
ylab='obs',
xlab='time')
for(i in 1:nS.user){
lines(x=res$data.p$time.p[[i]],y=res$segments[[i]],col='blue')
rect(xleft=res$data.p$time.p[[i]][1],
xright=rev(res$data.p$time.p[[i]])[1],
ybottom=uncertainty95_segment[[i]][1],
ytop=uncertainty95_segment[[i]][2],
col= rgb(0,0,1,alpha=0.2),
border = 'transparent')
}
uncertainty95_shift
i
i <- 1
uncertainty95_shift[[i]][1]
abline(v=res$tau,col='green', lwd=2)
plot(x=obs_segmented$obs,
col=factor(obs_segmented$period),
pch=16,
main='Final segmentation',
ylab='obs',
xlab='time')
plot(x=obs_segmented$obs,
col=factor(obs_segmented$period),
pch=16,
main='Final segmentation',
ylab='obs',
xlab='time')
abline(v=res$tau,col='green', lwd=2)
rect(xleft=uncertainty95_shift[[i]][1],
xright=rev(uncertainty95_shift[[i]])[1],
ybottom=min(obs)*2,
ytop=max(obs)*2,
col= rgb(0,1,0,alpha=0.2),
border = 'transparent')
rev(uncertainty95_shift[[i]])[1]
uncertainty95_shift
rev(uncertainty95_shift[[i]])
uncertainty95_shift
uncertainty95_shift[[i]]
uncertainty95_shift[[i]]
plot(x=obs_segmented$obs,
col=factor(obs_segmented$period),
pch=16,
main='Final segmentation',
ylab='obs',
xlab='time')
for(i in 1:nS.user){
lines(x=res$data.p$time.p[[i]],y=res$segments[[i]],col='blue')
rect(xleft=res$data.p$time.p[[i]][1],
xright=rev(res$data.p$time.p[[i]])[1],
ybottom=uncertainty95_segment[[i]][1],
ytop=uncertainty95_segment[[i]][2],
col= rgb(0,0,1,alpha=0.2),
border = 'transparent')
}
for(i in 1:(nS.user-1)){
abline(v=res$tau,col='green', lwd=2)
if(i==1){
rect(xleft=uncertainty95_shift[[1]],
xright=uncertainty95_shift[[2]],
ybottom=min(obs)*2,
ytop=max(obs)*2,
col= rgb(0,1,0,alpha=0.2),
border = 'transparent')
}else{
rect(xleft=uncertainty95_shift[[i]][1],
xright=rev(uncertainty95_shift[[i]])[1],
ybottom=min(obs)*2,
ytop=max(obs)*2,
col= rgb(0,1,0,alpha=0.2),
border = 'transparent')
}
}
library(RatingShiftHappens)
?segmentation.engine
quantiles
library(RatingShiftHappens)
quantile
?quantile
?read.table
?which.max
set.seed(1)
# Create observation vector
obs=c(rnorm(25,mean=0,sd=1),rnorm(25,mean=2,sd=1))
nS.user=2
# Run segmentation engine function
res <- segmentation.engine(obs=obs,nS=nS.user)
# Estimated shift time
res$tau
# Maximum a posterior value per segment indexed by the list number
res$segments
# Uncertainty in shift time
Shift=res$mcmc$tau1
hist(Shift)
uncertainty95_shift = quantile(Shift,probs=c(0.025,0.975))
# Uncertainty in segment estimation
mu.seg.1.unc=res$mcmc$mu1
hist(mu.seg.1.unc,
xlab='obs',
main='Histogram of first segment of observation')
uncertainty95_segment <- list()
for(i in 1:nS.user){
uncertainty95_segment [[i]] = quantile(res$mcmc[,i],probs=c(0.025,0.975))
}
# Separate and assign information by identified stable period
res$data.p
# DIC estimation
res$DIC
# Plot
obs_segmented <- data.frame()
for(i in 1:length(res$data.p$obs.p)){
obs_segmented_temp=cbind(obs=res$data.p$obs.p[[i]],period=i)
obs_segmented=rbind(obs_segmented,obs_segmented_temp)
}
plot(x=obs_segmented$obs,
col=factor(obs_segmented$period),
pch=16,
main='Final segmentation',
ylab='obs',
xlab='time')
for(i in 1:nS.user){
lines(x=res$data.p$time.p[[i]],y=res$segments[[i]],col='blue')
rect(xleft=res$data.p$time.p[[i]][1],
xright=rev(res$data.p$time.p[[i]])[1],
ybottom=uncertainty95_segment[[i]][1],
ytop=uncertainty95_segment[[i]][2],
col= rgb(0,0,1,alpha=0.2),
border = 'transparent')
}
for(i in 1:(nS.user-1)){
abline(v=res$tau,col='green', lwd=2)
if(i==1){
rect(xleft=uncertainty95_shift[[1]],
xright=uncertainty95_shift[[2]],
ybottom=min(obs)*2,
ytop=max(obs)*2,
col= rgb(0,1,0,alpha=0.2),
border = 'transparent')
}else{
rect(xleft=uncertainty95_shift[[i]][1],
xright=rev(uncertainty95_shift[[i]])[1],
ybottom=min(obs)*2,
ytop=max(obs)*2,
col= rgb(0,1,0,alpha=0.2),
border = 'transparent')
}
}
?hist
?quantile
library(RatingShiftHappens)
library(RatingShiftHappens)
?segmentation.engine
# Set random generation
set.seed(1)
# Create observation vector
obs=c(rnorm(25,mean=0,sd=1),rnorm(25,mean=2,sd=1))
nS.user=2
# Run segmentation engine function
res <- segmentation.engine(obs=obs,nS=nS.user)
# Estimated shift time
res$tau
# Maximum a posterior value per segment indexed by the list number
res$segments
# Uncertainty in shift time
Shift=res$mcmc$tau1
hist(Shift)
uncertainty95_shift = quantile(Shift,probs=c(0.025,0.975))
# Uncertainty in segment estimation
mu.seg.1.unc=res$mcmc$mu1
graphics::hist(mu.seg.1.unc,
xlab='obs',
main='Histogram of first segment of observation')
uncertainty95_segment <- list()
for(i in 1:nS.user){
uncertainty95_segment [[i]] = stats::quantile(res$mcmc[,i],probs=c(0.025,0.975))
}
# Separate and assign information by identified stable period
res$data.p
# DIC estimation
res$DIC
# Plot
obs_segmented <- data.frame()
for(i in 1:length(res$data.p$obs.p)){
obs_segmented_temp=cbind(obs=res$data.p$obs.p[[i]],period=i)
obs_segmented=rbind(obs_segmented,obs_segmented_temp)
}
plot(x=obs_segmented$obs,
col=factor(obs_segmented$period),
pch=16,
main='Final segmentation',
ylab='obs',
xlab='time')
for(i in 1:nS.user){
lines(x=res$data.p$time.p[[i]],y=res$segments[[i]],col='blue')
rect(xleft=res$data.p$time.p[[i]][1],
xright=rev(res$data.p$time.p[[i]])[1],
ybottom=uncertainty95_segment[[i]][1],
ytop=uncertainty95_segment[[i]][2],
col= rgb(0,0,1,alpha=0.2),
border = 'transparent')
}
for(i in 1:(nS.user-1)){
abline(v=res$tau,col='green', lwd=2)
if(i==1){
rect(xleft=uncertainty95_shift[[1]],
xright=uncertainty95_shift[[2]],
ybottom=min(obs)*2,
ytop=max(obs)*2,
col= rgb(0,1,0,alpha=0.2),
border = 'transparent')
}else{
rect(xleft=uncertainty95_shift[[i]][1],
xright=rev(uncertainty95_shift[[i]])[1],
ybottom=min(obs)*2,
ytop=max(obs)*2,
col= rgb(0,1,0,alpha=0.2),
border = 'transparent')
}
}
<!-- # ```{r example} -->
#
# ```
build_readme()
# ```{r example}
#
# ```
build_readme()
library(RatingShiftHappens)
# ```{r example}
#
# ```
build_readme()
# Set random generation
set.seed(1)
# Create series to be segmented
obs=c(rnorm(30,mean=0,sd=1),rnorm(30,mean=2,sd=1))
time=1:length(obs)
# Apply recursive segmentation
results=recursive.segmentation(obs)
# Have a look at recursion tree
results$tree
# Get terminal nodes
terminal=which(results$tree$nS==1)
# Plot original series and terminal nodes defining final segments
X11();plot(time,obs)
for(i in 1:length(terminal)){
data.stable.p=results$res[[terminal[i]]]$results[[1]]   #Save data from stable period
node=list(obs=data.stable.p$data.p$obs.p,
times=data.stable.p$data.p$time.p,
u=data.stable.p$data.p$u.p)
points(node$times,node$obs,col=i)
text(node$times,node$obs,terminal[i],pos=3,col=i)
}
# Get time shifts
time.shifts=which(results$tree$nS!=1)
for(i in 1:length(time.shifts)){
nSopt.p = results$res[[time.shifts[[i]]]]$nS
abline(v=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$tau,col='green')
abline(v=quantile(results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$mcmc$tau1,probs=c(0.025,0.975)),col='green',lty=2)
segments(
x0=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$data.p$time.p[[1]][1],
x1=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$tau,
y0=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$segments[[1]],
y1=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$segments[[1]],
col='blue')
segments(
x0=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$tau,
x1=rev(results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$data.p$time.p[[2]])[1],
y0=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$segments[[2]],
y1=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$segments[[2]],
col='blue')
}
# Visualize tree with data.tree package
if(NROW(results$tree)>1){
tree <- data.tree::as.Node(results$tree[-1,c(3,1)],mode = "network")
plot(tree)
} else { # No segmentation took place, make a dummy plot
tree <- data.tree::as.Node(data.frame(1,2),mode = "network")
plot(tree)
}
# ```{r example}
#
# ```
build_readme()
git commit --no-verify
git
?git
??git
git
devtools::install_github("username/packagename")
git config --global user.name 'yourGitHubUsername'
