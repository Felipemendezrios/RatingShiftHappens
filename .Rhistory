k=k+1 # Increment main counter
foo=seg(X[[j]],TIME[[j]]) # Apply segmentation to subseries stored in node X[[j]]
# Save results for this node
allRes[[k]]=foo
# Update recursion tree
tree=rbind(tree,data.frame(indx=k,level=level,parent=parents[j],nS=foo$nS))
# This was the trickiest part: keeping track of indices and parents
keepgoing[j]=foo$nS>1 # if nS=1, segmentation will not continue for this node which is hence terminal
if(keepgoing[j]){ # Save results for segmentation at next level
for(i in 1:foo$nS){ # Loop on each segment detected for the current node
p=p+1 # Increment auxiliary counter
m=m+1 # Increment local counter
newX[[m]]=foo$segments[[i]] # Save ith segment (on a total of nS)
newTIME[[m]]=foo$times[[i]] # Save corresponding times
newParents[m]=indices[j] # At next level, the parent of this segment will be the index of current node
newIndices[m]=p # At next level, the index of this segment will be p
}
}
}
# Check if recursion should continue at all, i.e. if at least one node is not terminal
if(all(keepgoing==FALSE)) continue=FALSE
# Update list of nodes to be further segmented at next level + parents and indices
X=newX
TIME=newTIME
parents=newParents
indices=newIndices
}
tree
newX
# Initialization
allRes=list() # store segmentation results for all nodes in a sequential list
k=0 # Main counter used to control indices in allRes
tree=data.frame() # store tree structure (parents - children relationship)
p=1 # Auxiliary counter needed to keep track of children / parents indices
level=0 # Recursion level. The tree is created level-by-level rather than branch-by-branch
X=list(x) # List of all nodes (each corresponding to a subseries of x) to be segmented at this level. Start with a unique node corresponding to the whole series
TIME=list(time) # List of corresponding times
indices=c(1) # Vector containing the indices of each node - same size as X
parents=c(0) # Vector containing the indices of the parents of each node - same size as X
continue=TRUE
level=level+1 # Increment recursion level
nX=length(X) # Number of nodes at this level
keepgoing=rep(NA,nX) # Should recursion continue for each node?
newX=newTIME=newIndices=newParents=c() # Will be used to update subseries, indices and parents at the end of each recursion level
m=0
nX
for(j in 1:nX){ # Loop on each node
k=k+1 # Increment main counter
foo=seg(X[[j]],TIME[[j]]) # Apply segmentation to subseries stored in node X[[j]]
# Save results for this node
allRes[[k]]=foo
# Update recursion tree
tree=rbind(tree,data.frame(indx=k,level=level,parent=parents[j],nS=foo$nS))
# This was the trickiest part: keeping track of indices and parents
keepgoing[j]=foo$nS>1 # if nS=1, segmentation will not continue for this node which is hence terminal
if(keepgoing[j]){ # Save results for segmentation at next level
for(i in 1:foo$nS){ # Loop on each segment detected for the current node
p=p+1 # Increment auxiliary counter
m=m+1 # Increment local counter
newX[[m]]=foo$segments[[i]] # Save ith segment (on a total of nS)
newTIME[[m]]=foo$times[[i]] # Save corresponding times
newParents[m]=indices[j] # At next level, the parent of this segment will be the index of current node
newIndices[m]=p # At next level, the index of this segment will be p
}
}
}
newX
foo$segments
foo$segments[[i]]
i
i <- 2
foo$segments
seg <- function(x,time=1:length(x)){
# Segmentation function
# Just a placeholder version to test the recursive part
# Estimate number of segments (here just a random choice between 1 and 3)
nS=sample(1:min(3,length(x)),1)
if(nS==1){
segments=x # Subseries = whole series
times=time
tau=NA # no shift time
} else {
# "Estimated" Shift times - in fact just a random split
tau=sort(sample(1:(length(x)-1),nS-1,replace = FALSE))
# Store subseries into a list
segments=times=vector(mode='list',length=nS)
augmentedTau=c(0,tau,length(x)) # complete taus with 0 and last time step to simplify next lines of code
for(i in 1:nS){
segments[[i]]=x[(augmentedTau[i]+1):augmentedTau[i+1]]
times[[i]]=time[(augmentedTau[i]+1):augmentedTau[i+1]]
}
}
return(list(nS=nS,times=times,segments=segments,tau=tau))
}
rec <- function(x,time){
# recursive segmentation
# Initialization
allRes=list() # store segmentation results for all nodes in a sequential list
k=0 # Main counter used to control indices in allRes
tree=data.frame() # store tree structure (parents - children relationship)
p=1 # Auxiliary counter needed to keep track of children / parents indices
level=0 # Recursion level. The tree is created level-by-level rather than branch-by-branch
X=list(x) # List of all nodes (each corresponding to a subseries of x) to be segmented at this level. Start with a unique node corresponding to the whole series
TIME=list(time) # List of corresponding times
indices=c(1) # Vector containing the indices of each node - same size as X
parents=c(0) # Vector containing the indices of the parents of each node - same size as X
continue=TRUE
while(continue){
level=level+1 # Increment recursion level
nX=length(X) # Number of nodes at this level
keepgoing=rep(NA,nX) # Should recursion continue for each node?
newX=newTIME=newIndices=newParents=c() # Will be used to update subseries, indices and parents at the end of each recursion level
m=0 # Local counter used to control indices in the 4 vectors above => reset to 0 at each new level of the recursion
for(j in 1:nX){ # Loop on each node
k=k+1 # Increment main counter
foo=seg(X[[j]],TIME[[j]]) # Apply segmentation to subseries stored in node X[[j]]
# Save results for this node
allRes[[k]]=foo
# Update recursion tree
tree=rbind(tree,data.frame(indx=k,level=level,parent=parents[j],nS=foo$nS))
# This was the trickiest part: keeping track of indices and parents
keepgoing[j]=foo$nS>1 # if nS=1, segmentation will not continue for this node which is hence terminal
if(keepgoing[j]){ # Save results for segmentation at next level
for(i in 1:foo$nS){ # Loop on each segment detected for the current node
p=p+1 # Increment auxiliary counter
m=m+1 # Increment local counter
newX[[m]]=foo$segments[[i]] # Save ith segment (on a total of nS)
newTIME[[m]]=foo$times[[i]] # Save corresponding times
newParents[m]=indices[j] # At next level, the parent of this segment will be the index of current node
newIndices[m]=p # At next level, the index of this segment will be p
}
}
}
# Check if recursion should continue at all, i.e. if at least one node is not terminal
if(all(keepgoing==FALSE)) continue=FALSE
# Update list of nodes to be further segmented at next level + parents and indices
X=newX
TIME=newTIME
parents=newParents
indices=newIndices
}
return(list(res=allRes,tree=tree))
}
# Test
#------------
# Create series to be segmented
n=50
x=rnorm(n);time=1:length(x)
# Apply recursive segmentation
results=rec(x,time)
# Have a look at recursion tree
results$tree
terminal=which(results$tree$nS==1)
terminal
View(results)
results$res[[terminal[i]]]
i
# Plot original series and terminal nodes defining final segments
X11();plot(time,x)
i <- 1
results$res[[terminal[i]]]
terminal
# Have a look at recursion tree
results$tree
# Get terminal nodes
terminal=which(results$tree$nS==1)
terminal
# Plot original series and terminal nodes defining final segments
X11();plot(time,x)
i <- 1
results$res[[terminal[i]]]
node=results$res[[terminal[i]]]
points(node$times,node$segments,col=i)
text(node$times,node$segments,terminal[i],pos=3,col=i)
terminal
results$tree
obs=c(rnorm(25,mean=0,sd=1),rnorm(25,mean=2,sd=1),rnorm(10,mean=5,sd=1),rnorm(5,mean=1,sd=1))
time=1:length(obs)
# Apply recursive segmentation
results=recursive.segmentation(obs)
library(RatingShiftHappens)
# Apply recursive segmentation
results=recursive.segmentation(obs)
is_in_intervals <- function(data, intervals) {
sapply(data, function(d) any(sapply(intervals, function(interval) d >= interval[1] & d <= interval[2])))
}
# Exemple d'utilisation
data <- c(1, 5, 10, 15, 20)
intervals <- cbind(c(0, 3), c(7, 12), c(18, 25))
result <- is_in_intervals(data, intervals)
print(result)
result
data
intervals
is_in_intervals <- function(data, intervals) {
sapply(data, function(d) any(sapply(intervals, function(interval) d >= interval[[1]] & d <= interval[[2]])))
}
# Exemple d'utilisation
data <- c(1, 5, 10, 15, 20)
intervals <- list(list(0, 3), list(7, 12), list(18, 25))
result <- is_in_intervals(data, intervals)
print(result)
intervals
get_values_in_intervals <- function(data, intervals) {
lapply(intervals, function(interval) data[data >= interval[[1]] & data <= interval[[2]]])
}
# Exemple d'utilisation
data <- c(1, 5, 10, 15, 20)
intervals <- list(list(0, 3), list(7, 12), list(18, 25))
result <- get_values_in_intervals(data, intervals)
print(result)
augmentedTau=c(0,tau.MAP,rev(time)[1])
0.0000 50.2143 64.0000
# Création des vecteurs intervalles et donnees
intervalles <- c(0.0000, 50.2143, 64)
donnees <- c(1, 2, 45, 52, 57, 64)
# Fonction pour identifier les données à l'intérieur de chaque intervalle
get_values_in_intervals <- function(data, intervals) {
result <- lapply(seq_along(intervals[-1]), function(i) {
idx <- which(data >= intervals[i] & data <= intervals[i+1])
data[idx]
})
return(result)
}
# Récupération des données à l'intérieur de chaque intervalle
donnees_dans_intervalles <- get_values_in_intervals(donnees, intervalles)
# Affichage des données à l'intérieur de chaque intervalle
print(donnees_dans_intervalles)
seq_along
?seq_along
seq_along(intervals[-1])
intervals
intervalles
# Création des vecteurs intervalles et donnees
intervalles <- c(0.0000, 50.2143, 64)
donnees <- c(1, 2, 45, 52, 57, 64)
# Utilisation de la fonction cut pour découper les données en intervalles
donnees_dans_intervalles <- cut(donnees, breaks = intervalles, include.lowest = TRUE, labels = FALSE)
# Affichage des données à l'intérieur de chaque intervalle
print(donnees_dans_intervalles)
donnees_dans_intervalles_liste <- split(donnees, donnees_dans_intervalles)
print(donnees_dans_intervalles_liste)
tau.MAP
intervals.time.shift=c(time[1],tau.MAP,rev(time)[1])
intervals.time.shift[i+1]
which((time-intervals.time.shift[i])>=0)[1]
set.seed(2023)
library(RatingShiftHappens)
?segmentation_engine
# Create observation vector
obs=c(rnorm(25,mean=0,sd=1),rnorm(25,mean=2,sd=1))
# Run segmentation engine function
res <- segmentation_engine(obs=obs)
# Estimated shift time
res$tau
# mean value per segment indexed by the list number
res$segments
# Uncertainty in shift time
hist(res$mcmc$tau1)
# Separate and assign information by identified stable period
res$data.p
# DIC estimation
res$DIC
# Plot
plot(obs)
lines(x=res$data.p$time.p[[1]],y=res$segments[[1]],col='blue')
lines(x=res$data.p$time.p[[2]],y=res$segments[[2]],col='blue')
abline(v=res$tau,col='green')
abline(v=quantile(res$mcmc$tau1,probs=c(0.025,0.975)),col='green',lty=2)
# Create observation vector
obs=c(rnorm(25,mean=0,sd=1),rnorm(25,mean=2,sd=1))
# Run segmentation function
res <- segmentation(obs=obs)
# Optimal number of segments nSopt
nSopt <- res$nS
nSopt
# Estimated shift time
res$results[[nSopt]]$tau
# Uncertainty in shift time
hist(res$results[[nSopt]]$mcmc$tau)
# Separate and assign information by identified stable period
res$results[[nSopt]]$data.p
# DIC estimation
res$results[[nSopt]]$DIC
# Plot
plot(obs)
lines(x=res$results[[res$nS]]$data.p$time.p[[1]],y=res$results[[res$nS]]$segments[[1]],col='blue')
lines(x=res$results[[res$nS]]$data.p$time.p[[2]],y=res$results[[res$nS]]$segments[[2]],col='blue')
abline(v=res$results[[nSopt]]$tau,col='green')
abline(v=quantile(res$results[[nSopt]]$mcmc$tau1,probs=c(0.025,0.975)),col='green',lty=2)
library(RatingShiftHappens)
?recursive.segmentation
?recursive.segmentation
library(RatingShiftHappens)
library(RatingShiftHappens)
?recursive.segmentation
source("~/Felipe_MENDEZ/GitHub/RatingShiftHappens/R/Segmentation.R")
library(RatingShiftHappens)
?recursive.segmentation
library(RatingShiftHappens)
?recursive.segmentation
library(RatingShiftHappens)
obs=c(rnorm(25,mean=0,sd=1),rnorm(25,mean=2,sd=1),rnorm(10,mean=5,sd=1),rnorm(5,mean=1,sd=1))
time=1:length(obs)
u=0*obs
nSmax=2
nMin= 1
nCycles=100
burn=0.5
nSlim=max(nCycles/10,1)
temp.folder=file.path(tempdir(),'BaM')
# Apply recursive segmentation
results=recursive.segmentation(obs)
# Have a look at recursion tree
results$tree
# Get terminal nodes
terminal=which(results$tree$nS==1)
# Plot original series and terminal nodes defining final segments
X11();plot(time,obs)
for(i in 1:length(terminal)){
data.stable.p=results$res[[terminal[i]]]$results[[1]]   #Save data from stable period
node=list(obs=data.stable.p$data.p$obs.p,
times=data.stable.p$data.p$time.p,
u=data.stable.p$data.p$u.p)
points(node$times,node$obs,col=i)
text(node$times,node$obs,terminal[i],pos=3,col=i)
}
# Get time shifts
time.shifts=which(results$tree$nS!=1)
for(i in 1:length(time.shifts)){
nSopt.p = results$res[[time.shifts[[i]]]]$nS
abline(v=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$tau,col='green')
abline(v=quantile(results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$mcmc$tau1,probs=c(0.025,0.975)),col='green',lty=2)
lines(x=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$data.p$time.p[[1]],y=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$segments[[1]],col='blue')
lines(x=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$data.p$time.p[[2]],y=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$segments[[2]],col='blue')
}
# Visualize tree with data.tree package
if(NROW(results$tree)>1){
tree <- data.tree::as.Node(results$tree[-1,c(3,1)],mode = "network")
plot(tree)
} else { # No segmentation took place, make a dummy plot
tree <- data.tree::as.Node(data.frame(1,2),mode = "network")
plot(tree)
}
library(RatingShiftHappens)
library(RatingShiftHappens)
,RatingShiftHappens
?RatingShiftHappens
??RatingShiftHappens
# Create observation vector
obs=c(rnorm(25,mean=0,sd=1),rnorm(25,mean=2,sd=1))
# Run segmentation function
res <- segmentation(obs=obs)
# Optimal number of segments nSopt
nSopt <- res$nS
nSopt
# Estimated shift time
res$results[[nSopt]]$tau
# Uncertainty in shift time
hist(res$results[[nSopt]]$mcmc$tau)
# Separate and assign information by identified stable period
res$results[[nSopt]]$data.p
# DIC estimation
res$results[[nSopt]]$DIC
# Plot
plot(obs)
lines(x=res$results[[res$nS]]$data.p$time.p[[1]],y=res$results[[res$nS]]$segments[[1]],col='blue')
lines(x=res$results[[res$nS]]$data.p$time.p[[2]],y=res$results[[res$nS]]$segments[[2]],col='blue')
abline(v=res$results[[nSopt]]$tau,col='green')
abline(v=quantile(res$results[[nSopt]]$mcmc$tau1,probs=c(0.025,0.975)),col='green',lty=2)
set.seed(2023)
# Create series to be segmented
obs=c(rnorm(30,mean=0,sd=1),rnorm(30,mean=2,sd=1))
time=1:length(obs)
# Apply recursive segmentation
results=recursive.segmentation(obs)
# Have a look at recursion tree
results$tree
# Get terminal nodes
terminal=which(results$tree$nS==1)
# Plot original series and terminal nodes defining final segments
X11();plot(time,obs)
for(i in 1:length(terminal)){
data.stable.p=results$res[[terminal[i]]]$results[[1]]   #Save data from stable period
node=list(obs=data.stable.p$data.p$obs.p,
times=data.stable.p$data.p$time.p,
u=data.stable.p$data.p$u.p)
points(node$times,node$obs,col=i)
text(node$times,node$obs,terminal[i],pos=3,col=i)
}
# Get time shifts
# time.shifts=which(results$tree$nS!=1)# for(i in 1:length(time.shifts)){# nSopt.p = results$res[[time.shifts[[i]]]]$nS# abline(v=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$tau,col='green')# abline(v=quantile(results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$mcmc$tau1,probs=c(0.025,0.975)),col='green',lty=2)# segments(# x0=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$data.p$time.p[[1]][1],# x1=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$tau,# y0=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$segments[[1]],# y1=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$segments[[1]],# col='blue')# segments(# x0=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$tau,# x1=rev(results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$data.p$time.p[[2]])[1],# y0=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$segments[[2]],# y1=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$segments[[2]],# col='blue')#'}
# Visualize tree with data.tree package
if(NROW(results$tree)>1){
tree <- data.tree::as.Node(results$tree[-1,c(3,1)],mode = "network")
plot(tree)
} else { # No segmentation took place, make a dummy plot
tree <- data.tree::as.Node(data.frame(1,2),mode = "network")
plot(tree)
}
set.seed(2023)
# Create series to be segmented
obs=c(rnorm(30,mean=0,sd=1),rnorm(30,mean=2,sd=1))
time=1:length(obs)
# Apply recursive segmentation
results=recursive.segmentation(obs)
# Have a look at recursion tree
results$tree
# Get terminal nodes
terminal=which(results$tree$nS==1)
# Plot original series and terminal nodes defining final segments
X11();plot(time,obs)
for(i in 1:length(terminal)){
data.stable.p=results$res[[terminal[i]]]$results[[1]]   #Save data from stable period
node=list(obs=data.stable.p$data.p$obs.p,
times=data.stable.p$data.p$time.p,
u=data.stable.p$data.p$u.p)
points(node$times,node$obs,col=i)
text(node$times,node$obs,terminal[i],pos=3,col=i)
}
# Get time shifts
# time.shifts=which(results$tree$nS!=1)# for(i in 1:length(time.shifts)){# nSopt.p = results$res[[time.shifts[[i]]]]$nS# abline(v=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$tau,col='green')# abline(v=quantile(results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$mcmc$tau1,probs=c(0.025,0.975)),col='green',lty=2)# segments(# x0=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$data.p$time.p[[1]][1],# x1=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$tau,# y0=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$segments[[1]],# y1=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$segments[[1]],# col='blue')# segments(# x0=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$tau,# x1=rev(results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$data.p$time.p[[2]])[1],# y0=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$segments[[2]],# y1=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$segments[[2]],# col='blue')#'}
# Visualize tree with data.tree package
if(NROW(results$tree)>1){
tree <- data.tree::as.Node(results$tree[-1,c(3,1)],mode = "network")
plot(tree)
} else { # No segmentation took place, make a dummy plot
tree <- data.tree::as.Node(data.frame(1,2),mode = "network")
plot(tree)
}
obs=c(rnorm(25,mean=0,sd=1),rnorm(25,mean=2,sd=1),rnorm(10,mean=5,sd=1),rnorm(5,mean=1,sd=1))
time=1:length(obs)
u=0*obs
nSmax=2
nMin= 1
nCycles=100
burn=0.5
nSlim=max(nCycles/10,1)
temp.folder=file.path(tempdir(),'BaM')
# Apply recursive segmentation
results=recursive.segmentation(obs)
# Have a look at recursion tree
results$tree
# Get terminal nodes
terminal=which(results$tree$nS==1)
# Plot original series and terminal nodes defining final segments
X11();plot(time,obs)
for(i in 1:length(terminal)){
data.stable.p=results$res[[terminal[i]]]$results[[1]]   #Save data from stable period
node=list(obs=data.stable.p$data.p$obs.p,
times=data.stable.p$data.p$time.p,
u=data.stable.p$data.p$u.p)
points(node$times,node$obs,col=i)
text(node$times,node$obs,terminal[i],pos=3,col=i)
}
# Get time shifts
time.shifts=which(results$tree$nS!=1)
for(i in 1:length(time.shifts)){
nSopt.p = results$res[[time.shifts[[i]]]]$nS
abline(v=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$tau,col='green')
abline(v=quantile(results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$mcmc$tau1,probs=c(0.025,0.975)),col='green',lty=2)
lines(x=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$data.p$time.p[[1]],y=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$segments[[1]],col='blue')
lines(x=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$data.p$time.p[[2]],y=results$res[[time.shifts[[i]]]]$results[[nSopt.p]]$segments[[2]],col='blue')
}
# Visualize tree with data.tree package
if(NROW(results$tree)>1){
tree <- data.tree::as.Node(results$tree[-1,c(3,1)],mode = "network")
plot(tree)
} else { # No segmentation took place, make a dummy plot
tree <- data.tree::as.Node(data.frame(1,2),mode = "network")
plot(tree)
}
library(RatingShiftHappens)
library(RatingShiftHappens)
?RatingShiftHappens
??RatingShiftHappens
?segmentation
# Create observation vector
obs=c(rnorm(25,mean=0,sd=1),rnorm(25,mean=2,sd=1))
# Run segmentation engine function
res <- segmentation_engine(obs=obs)
# Estimated shift time
res$tau
# mean value per segment indexed by the list number
res$segments
# Uncertainty in shift time
hist(res$mcmc$tau1)
# Separate and assign information by identified stable period
res$data.p
# DIC estimation
res$DIC
# Plot
plot(obs)
lines(x=res$data.p$time.p[[1]],y=res$segments[[1]],col='blue')
lines(x=res$data.p$time.p[[2]],y=res$segments[[2]],col='blue')
abline(v=res$tau,col='green')
abline(v=quantile(res$mcmc$tau1,probs=c(0.025,0.975)),col='green',lty=2)
library(RatingShiftHappens)
?segmentation
library(RatingShiftHappens)
?segmentation.engine
library(RatingShiftHappens)
?mcmcOptions
?mcmcCooking
?remnantErrorModel
?parameter
?xtraModelInfo
?model
?BaM
cat("\014") # Clear console
rm(list=ls())# Clean workspace
set.seed(2023)  #Set seed for reproducibility
