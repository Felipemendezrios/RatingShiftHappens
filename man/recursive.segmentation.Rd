% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Segmentation.R
\name{recursive.segmentation}
\alias{recursive.segmentation}
\title{Recursive segmentation}
\usage{
recursive.segmentation(
  obs,
  time = 1:length(obs),
  u = 0 * obs,
  nSmax = 2,
  nMin = 1,
  nCycles = 100,
  burn = 0.5,
  nSlim = max(nCycles/10, 1),
  temp.folder = file.path(tempdir(), "BaM")
)
}
\arguments{
\item{obs}{real vector, observations}

\item{time}{real vector, time}

\item{u}{real vector, uncertainty in observations (as a standard deviation)}

\item{nSmax}{integer, maximum number of segments to assess}

\item{nMin}{integer, minimum number of observations by segment}

\item{nCycles}{integer, number of MCMC adaptation cycles. Total number of simulations equal to 100*nCycles.}

\item{burn}{real between 0 (included) and 1 (excluded), MCMC burning factor}

\item{nSlim}{integer, MCMC slim step}

\item{temp.folder}{directory, temporary directory to write computations}
}
\value{
List with the following components :
\enumerate{
\item tau: real vector, estimated shift times
\item segments: list, segment maximum a posterior (MAP) value indexed by the list number
\item mcmc: data frame, MCMC simulation
\item data.p: list, separate and assign information by identified stable period indexed by the list number
\item DIC: real, DIC estimation
\item nS: integer, optimal number of segments following DIC criterion
\item tree : data frame, table for tree structure after segmentation
}
}
\description{
Recursive segmentation procedure for a \strong{unknown} given number of segments
}
\examples{

# Set random generation
set.seed(1)

# Create series to be segmented
obs=c(rnorm(30,mean=0.5,sd=1),
      rnorm(30,mean=1.5,sd=1),
      rnorm(30,mean=1,sd=1),
      rnorm(30,mean=2,sd=1))

time=1:length(obs)

# Assign a maximum number of user-defined segments to be assessed
nSmax.user=3

# Apply recursive segmentation
results=recursive.segmentation(obs, nSmax=nSmax.user)

# Have a look at recursion tree
results$tree


# Get terminal nodes
terminal=which(results$tree$nS==1)

# Get node with time shifts
nodes.shift.time=which(results$tree$nS!=1)

nodes.shift.time

# Estimated shift time along with uncertainties
shift.time.list <- c()
for(i in 1:length(nodes.shift.time)){
  nSopt.p = results$res[[nodes.shift.time[[i]]]]$nS
  results.p=results$res[[nodes.shift.time[[i]]]]$results
  # shift.time.p=results.p[[nSopt.p]]$tau
  shift.time.p=cbind(c(results.p[[nSopt.p]]$tau))

  for(j in 1:(nSopt.p-1)){

    shift.time.p.unc=data.frame(tau=as.numeric(shift.time.p[j,]),
                                u2.5=stats::quantile(results.p[[nSopt.p]]$mcmc[,nSopt.p+j],
                                                     probs=c(0.025)),
                                u97.5=stats::quantile(results.p[[nSopt.p]]$mcmc[,nSopt.p+j],
                                                      probs=c(0.975)))
    shift.time.list <- rbind(shift.time.list,
                             shift.time.p.unc)
  }
}

all.shift.time <- shift.time.list[order(shift.time.list$tau),]
all.shift.time

# intervals defined by time shifts
intervals.time.shift=c(results$res[[1]]$results[[1]]$data.p$time.p[1],
                       all.shift.time$tau,
                       rev(results$res[[1]]$results[[1]]$data.p$time.p)[1])

# Get stable periods by adding information as period, segment,
data.stable <- c()
for(i in 1:length(terminal)){
  data.stable.p=results$res[[terminal[i]]]$results[[1]]   #Save data from stable period

  node = data.frame(obs=data.stable.p$data.p$obs.p,
                    time=data.stable.p$data.p$time.p,
                    u=data.stable.p$data.p$u.p,
                    period = rep(i,length(data.stable.p$data.p$obs.p)))
  data.stable = rbind(data.stable,node)
}

# Setting plot

# Transparency
alpha <- 125

# Set color plot
color_customized_rect <- function(alpha){
  color <-  list(rgb(0, 255, 170, max = 255, alpha = alpha, names ='green'),
                 rgb(0, 221, 255, max = 255, alpha = alpha, names='sky blue'),
                 rgb(255, 0, 255, max = 255, alpha = alpha, names='purple'),
                 rgb(255, 157, 0, max = 255, alpha = alpha, names='orange'),
                 rgb(255, 0, 212, max = 255, alpha = alpha, names='magenta' ))
  return(color)
}

# Plot observations
plot(x=data.stable$time,
     y=data.stable$obs,
     col=data.stable$period,
     xlab='time',
     ylab='obs',
     main='Final segmentation'
)

# Plot shifts
for(i in 1:nrow(all.shift.time)){
  abline(v=all.shift.time$tau[i],
         col=color_customized_rect(255)[[i]])
  rect(xleft=all.shift.time$u2.5[[i]],
       xright=all.shift.time$u97.5[[i]],
       ybottom=min(obs)*2,
       ytop=max(obs)*2,
       col= color_customized_rect(50)[[i]],
       border = 'transparent')
}

# Pre-treatment data to extract segments from corresponding node
all.global.data <- c()
for(i in 1:length(nodes.shift.time)){
  nSopt.p = results$res[[nodes.shift.time[[i]]]]$nS
  results.p=results$res[[nodes.shift.time[[i]]]]$results

relation.parent.children.p=results$tree[which(results$tree$parent==nodes.shift.time[[i]]),]
  id.segment.p=which(relation.parent.children.p$nS==1)

  for(j in 1:length(id.segment.p)){
    segments.p=results.p[[nSopt.p]]$segments[[id.segment.p[[j]]]]
    obs.p=results.p[[nSopt.p]]$data.p$obs.p[[id.segment.p[[j]]]]
    time.p=results.p[[nSopt.p]]$data.p$time.p[[id.segment.p[[j]]]]
    u.p=results.p[[nSopt.p]]$data.p$u.p[[id.segment.p[[j]]]]
    unc.segment.p=stats::quantile(results.p[[nSopt.p]]$mcmc[,id.segment.p[[j]]],
                                  probs=c(0.025,0.975))


    data.p.temp=data.frame(mu=segments.p,
                           obs=obs.p,
                           u=u.p,
                           time=time.p,
                           u2.5=rep(unc.segment.p[1],length(segments.p)),
                           u97.5=rep(unc.segment.p[2],length(segments.p)))

    all.global.data=rbind(all.global.data,data.p.temp)
  }
}

all.global.data=all.global.data[order(all.global.data$time),]

final.data.segmented=unname((split(all.global.data,all.global.data$mu)))

# Plot segments
for(i in 1:(nrow(all.shift.time)+1)){
  text(final.data.segmented[[i]]$time,
       final.data.segmented[[i]]$obs,
       terminal[i],pos=3,
       cex=0.8,
       col='black')
  segments(x0=intervals.time.shift[[i]],
           x1=intervals.time.shift[[i+1]],
           y0=final.data.segmented[[i]]$mu,
           y1=final.data.segmented[[i]]$mu,
           col='blue')
  rect(xleft=intervals.time.shift[[i]],
       xright=intervals.time.shift[[i+1]],
       ybottom=final.data.segmented[[i]]$u2.5,
       ytop=final.data.segmented[[i]]$u97.5,
       col= rgb(0,0,255,max=255,alpha=5,names='blue'),
       border = 'transparent')
}
}
