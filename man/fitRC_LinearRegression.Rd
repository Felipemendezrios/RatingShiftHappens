% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit.R
\name{fitRC_LinearRegression}
\alias{fitRC_LinearRegression}
\title{Fit rating curve using simplified BaRatin model}
\usage{
fitRC_LinearRegression(time, H, Q, uQ)
}
\arguments{
\item{time}{real vector, time}

\item{H}{real vector, stage}

\item{Q}{real vector, discharge}

\item{uQ}{real vector, uncertainty in discharge (as a standard deviation)}
}
\value{
list with the following components :
\enumerate{
\item ResultsResiduals : data frame, results after fitting curve
\itemize{
\item time: real value, time
\item H: real value, stage
\item Q_obs: real value, discharge observed
\item Q_sim: real value, discharge simulated
\item Q_res: real value, residual between discharge observed and simulated
\item uQ_obs: real value, uncertainty in discharge observed (as a standard deviation)
\item uQ_sim: real value, uncertainty in discharge simulated (as a standard deviation)
}
\item parameters : data frame, parameters of the simplified BaRatin model : \deqn{Q(h)=a \cdot (H - b)^ (5/3)}
\itemize{
\item a : real value, parameter of geometry component
\item b : real value, parameter of offset (thalweg or streambed)
}
}
#' fitRC_Simplified_BaRatin=function(time,H,Q,uQ,
#'                                   b.distr = 'Gaussian' ,a.distr = 'LogNormal',
#'                                   b.prior, st_b.prior,
#'                                  Bc.prior, KS.prior, S0.prior,
#'                                  hmax_Xtra=1.5\emph{max(H)){
#'   # Hardcoded variables
#'   hyr_contr_matrix=matrix(c(1),nrow=1,ncol=1)
#'   c = 5/3
#'
#'   if(is.null(check_square_matrix(hyr_contr_matrix)))stop('Matrix must be square. Try another hydraulic matrix control')
#'   if(is.null(check_vector_lengths(hyr_contr_matrix,
#'                                   b.prior, Bc.prior, KS.prior, S0.prior)))stop('Prior information of the parameters does not have the same length')
#'   if(is.null(check_vector_lengths(hyr_contr_matrix,
#'                                   st_b.prior,st_Bc.prior,st_KS.prior, st_S0.prior)))stop('Prior information of the parameters does not have the same length')
#'
#'   #  How to handle uncertainty of the parameters? because depends on the distribution, number of parameters can vary
#'   if(is.null(check_param_distribution(b.distr,st_b.prior)))stop('The number of the parameters does not match with the specified distribution for st_b.prior')
#'   if(is.null(check_param_distribution(a.distr,st_Bc.prior)))stop('The number of the parameters does not match with the specified distribution for st_Bc.prior')
#'   if(is.null(check_param_distribution(a.distr,st_KS.prior)))stop('The number of the parameters does not match with the specified distribution for st_KS.prior')
#'   if(is.null(check_param_distribution(a.distr,st_S0.prior)))stop('The number of the parameters does not match with the specified distribution for st_S0.prior')
#'   if(is.null(check_param_distribution(g1.distr.type,g1.prior)))stop('The number of the parameters does not match with the specified distribution for g1.prior')
#'   if(is.null(check_param_distribution(g2.distr.type,g2.prior)))stop('The number of the parameters does not match with the specified distribution for g2.prior')
#'
#'   npar = 3}ncol(hyr_contr_matrix) #'  Three parameters by control
#'   priors <- vector(mode = 'list',length = npar)
#'
#'   for(i in 1 :ncol(hyr_contr_matrix)){
#'     b1=RBaM::parameter(name=paste0('b',i),
#'                        init=b.prior\link{i},
#'                        prior.dist = b.distr ,
#'                        prior.par = st_b.prior)
#'       parameter(name='k1',init=-0.5,prior.dist='Uniform',prior.par=c(-1.5,0))
#'
#'   }
#'   #'  put all parameters in priors
#'   data=data.frame(time=time,H=H,Q=Q)
#'
#'   ## ending
#'   #  residual data frame
#'   ResultsResiduals=data.frame(time=data$time,
#'                               H=data$H,
#'                               Q_obs=data$Q,
#'                               Q_sim=qsim,
#'                               Q_res=residuals,
#'                               uQ_obs=uQ,
#'                               uQ_sim=residual_sd
#'   )
#'   parameters=data.frame(a=Q0,b=mu)
#'
#'   return(list(ResultsResiduals=ResultsResiduals,
#'               parameters=parameters))
#' }
#'
#'
#'

Fit rating curve using a linear regression

Linear regression used to estimate a simple rating curve. Formula : \deqn{Q(h)= a \cdot h + b}

List with the following components :
\enumerate{
\item ResultsResiduals : data frame, results after fitting curve
\itemize{
\item time: real value, time
\item H: real value, stage
\item Q_obs: real value, discharge observed
\item Q_sim: real value, discharge simulated
\item Q_res: real value, residual between discharge observed and simulated
\item uQ_obs: real value, uncertainty in discharge observed (as a standard deviation)
\item uQ_sim: real value, uncertainty in discharge simulated (as a standard deviation)
}
\item parameters : data frame, parameters of the linear regression expressed \deqn{Q(h)= a \cdot h + b}
\itemize{
\item a : real value, parameter of the linear regression
\item b : real value, parameter of the linear regression
}
}
}
\description{
Rating curve estimated by using BaRatin approach with the parameter c set to (5/3) and single rectangular weir as hydraulic control. The input data must be already ordered.
}
\examples{
# Dataset
subset = RhoneRiver[1:20,]

# Linear regression to estimate a simple rating curve
fit.funk=fitRC_LinearRegression(time=subset$Time,H=subset$H,Q=subset$Q,uQ=subset$uQ)
fit=fit.funk$ResultsResiduals

# Parameters of the linear regression
fit.funk$parameters

# plot rating curve with model results
plot(fit$H, fit$Q_obs, ylim = range(c(fit$Q_obs - fit$uQ_obs, fit$Q_obs + fit$uQ_obs)),
     xlab = "H", ylab = "Q_obs")

# Add error bars following uQ_obs
arrows(fit$H, fit$Q_obs - fit$uQ_obs, fit$H, fit$Q_obs + fit$uQ_obs, angle = 90,
       code = 3, length = 0.1)

# Linear regression
lines(x=fit$H,y=fit$Q_sim, col="blue",lty=3, lwd=2)

# plot residuals
plot(x=fit$time,y=fit$Q_res, ylim = range(c(fit$Q_res - fit$uQ_obs, fit$Q_res + fit$uQ_obs)),
     xlab='H', ylab='Residual')
arrows(fit$time, fit$Q_res - fit$uQ_obs, fit$time, fit$Q_res + fit$uQ_obs, angle = 90,
       code = 3, length = 0.1)
abline(h=0, col='red')
}
