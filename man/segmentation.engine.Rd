% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Segmentation.R
\name{segmentation.engine}
\alias{segmentation.engine}
\title{Segmentation engine}
\usage{
segmentation.engine(
  obs,
  time = 1:length(obs),
  u = 0 * obs,
  nS = 2,
  nMin = 1,
  nCycles = 100,
  burn = 0.5,
  nSlim = max(nCycles/10, 1),
  temp.folder = file.path(tempdir(), "BaM")
)
}
\arguments{
\item{obs}{real vector, observations}

\item{time}{real vector, time}

\item{u}{real vector, uncertainty in observations (as a standard deviation)}

\item{nS}{integer, number of segments}

\item{nMin}{integer, minimum number of observations by segment}

\item{nCycles}{integer, number of MCMC adaptation cycles. Total number of simulations equal to 100*nCycles}

\item{burn}{real between 0 (included) and 1 (excluded), MCMC burning factor}

\item{nSlim}{integer, MCMC slim step}

\item{temp.folder}{directory, temporary directory to write computations}
}
\value{
List with the following components :
\enumerate{
\item tau: real vector, estimated shift times
\item segments: list, segment maximum a posterior (MAP) value indexed by the list number
\item mcmc: data frame, MCMC simulation
\item data.p: list, separate and assign information by identified stable period indexed by the list number
\item DIC: real, DIC estimation
}
}
\description{
Segmentation procedure for a \strong{known} given number of segments
}
\examples{
# Set random generation
set.seed(1)

# Create observation vector
obs=c(rnorm(25,mean=0,sd=1),rnorm(25,mean=2,sd=1))
nS.user=2

# Run segmentation engine function
res <- segmentation.engine(obs=obs,nS=nS.user)

# Estimated shift time
res$tau

# Maximum a posterior value per segment indexed by the list number
res$segments

# Uncertainty in shift time
Shift=res$mcmc$tau1
hist(Shift)

uncertainty95_shift = quantile(Shift,probs=c(0.025,0.975))

# Uncertainty in segment estimation
mu.seg.1.unc=res$mcmc$mu1
graphics::hist(mu.seg.1.unc,
               xlab='obs',
               main='Histogram of first segment of observation')
           uncertainty95_segment <- list()
for(i in 1:nS.user){
   uncertainty95_segment [[i]] = stats::quantile(res$mcmc[,i],probs=c(0.025,0.975))
 }

 # Separate and assign information by identified stable period
 res$data.p
 # DIC estimation
 res$DIC

 # Plot
 obs_segmented <- data.frame()
for(i in 1:length(res$data.p$obs.p)){
 obs_segmented_temp=cbind(obs=res$data.p$obs.p[[i]],period=i)
 obs_segmented=rbind(obs_segmented,obs_segmented_temp)
}

plot(x=obs_segmented$obs,
  col=factor(obs_segmented$period),
  pch=16,
  main='Final segmentation',
  ylab='obs',
  xlab='time')

for(i in 1:nS.user){
  lines(x=res$data.p$time.p[[i]],y=res$segments[[i]],col='blue')
  rect(xleft=res$data.p$time.p[[i]][1],
       xright=rev(res$data.p$time.p[[i]])[1],
       ybottom=uncertainty95_segment[[i]][1],
       ytop=uncertainty95_segment[[i]][2],
       col= rgb(0,0,1,alpha=0.2),
       border = 'transparent')
}
for(i in 1:(nS.user-1)){
  abline(v=res$tau,col='green', lwd=2)
  if(i==1){
    rect(xleft=uncertainty95_shift[[1]],
         xright=uncertainty95_shift[[2]],
         ybottom=min(obs)*2,
         ytop=max(obs)*2,
         col= rgb(0,1,0,alpha=0.2),
         border = 'transparent')
  }else{
    rect(xleft=uncertainty95_shift[[i]][1],
         xright=rev(uncertainty95_shift[[i]])[1],
         ybottom=min(obs)*2,
         ytop=max(obs)*2,
         col= rgb(0,1,0,alpha=0.2),
         border = 'transparent')
  }
}
}
