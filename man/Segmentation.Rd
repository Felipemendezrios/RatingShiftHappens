% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Segmentation.R
\name{Segmentation}
\alias{Segmentation}
\title{Segmentation}
\usage{
Segmentation(
  obs,
  time = 1:length(obs),
  u = 0 * obs,
  nSmax = 2,
  nMin = ifelse(doQuickApprox, 3, 1),
  nCycles = 100,
  burn = 0.5,
  nSlim = max(nCycles/10, 1),
  temp.folder = file.path(tempdir(), "BaM"),
  mu_prior = list(),
  doQuickApprox = TRUE,
  varShift = FALSE,
  alpha = 0.1,
  ...
)
}
\arguments{
\item{obs}{real vector, observations}

\item{time}{real vector, time in POSIXct, string or numeric format}

\item{u}{real vector, uncertainty in observations (as a standard deviation)}

\item{nSmax}{integer, maximum number of segments to assess}

\item{nMin}{integer, minimum number of observations by segment}

\item{nCycles}{integer, number of MCMC adaptation cycles. Total number of simulations equal to 100*nCycles}

\item{burn}{real between 0 (included) and 1 (excluded), MCMC burning factor}

\item{nSlim}{integer, MCMC slim step}

\item{temp.folder}{directory, temporary directory to write computations}

\item{mu_prior}{list, object describing prior knowledge about residual between the rating curve and observation if user-defined (see details)}

\item{doQuickApprox}{logical, use quick approximation? see ?Segmentation_quickApprox}

\item{varShift}{logical, allow for a shifting variance? Only used when doQuickApprox=TRUE.}

\item{alpha}{real in (0;1), type-I error level of the underlying step-change test. Only used when doQuickApprox=TRUE.}

\item{...}{other arguments passed to RBaM::BaM.}
}
\value{
list with the following components:
\enumerate{
\item summary: list, summarize the information to present to the user
\itemize{
\item data: data frame, all data with their respective periods after segmentation
\item shift: data frame, all detected shift time in numeric or POSIXct format in UTC
}
\item plot : list, data formatted to use as input for some plot functions
\item res: list, provide all the information of the periods from tree structure
\itemize{
\item tau: real vector, estimated shift times in numeric or POSIXct format in UTC
\item segments: list, segment maximum a posterior (MAP) value indexed by the list number
\item mcmc: data frame, MCMC simulation
\item data.p: list, separate and assign information by identified stable period indexed by the list number
\item DIC: real, DIC estimation
\item origin.date: positive real or date, date describing origin of the segmentation for a sample. Useful for recursive segmentation.
}
\item nS: integer, optimal number of segments following DIC criterion
}
}
\description{
Segmentation procedure for an \strong{unknown} given number of segments
}
\details{
User may enter prior knowledge about the mu parameter (see \code{?Segmentation_Engine}) instead of default values.
This information must be provided using the parameter function in the RBaM package, as shown in the example.
}
\examples{
# Run segmentation engine function at two segments
res=Segmentation(obs=RhoneRiverAMAX$H,time=RhoneRiverAMAX$Year,u=RhoneRiverAMAX$uH)

# Verify optimal nS corresponds to lowest DIC value
res$nS
res$results[[1]]$DIC
res$results[[2]]$DIC

# Data information
knitr::kable(head(res$results[[res$nS]]$summary$data),
             align = 'c',row.names = FALSE)
# Shift information
knitr::kable(head(res$results[[res$nS]]$summary$shift),
             align = 'c',row.names = FALSE)
# Plot segmentation
PlotSegmentation(res$summary,res$plot)
}
